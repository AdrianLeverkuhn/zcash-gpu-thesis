% Chapter Template

\chapter{zCash and zk-SNARKs} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{zCash}

Cryptocurrencies have gained in popularity over the last couple of years. The best example is the Bitcoin bubble which made people gain millions over night, and lose them soon after. However, Bitcoin is of limited use today. It cannot be used as a general currency due to the low throughput and long waiting times for the transaction to be added to the block. Its status as an anonymous currency is also disputed, resulting in 2 different cryptocurrencies being developed to fill that void - Monero and zCash (ZEC).\\
\\
ZCash defines two types of addresses. Transparent addresses behave the same way as Bitcoin addresses. Data resides in the public blockchain, so it can be tracked the same way as with Bitcoin. However, shielded addresses reveal nothing when they are a part of the transaction. This is accomplished by using notes (NOTE) which contain the public key (PK) of the owner, some amount of zCash (M), as well as a unique identifier (N). Every shielded transaction results in a note like this (transaction output). When this note is used in a transaction, it is spent, and its nullifier (NULL(N)) is published. Valid, unspent notes are ones which are in the set of all generated notes, and whose nullifier hasn't been published.\\
\\
Keeping all notes in a list would result is abysmal performance, so they are kept in a Merkle tree. Furthermore, instead of keeping notes in a public structure, where everyone can see them, we keep commitments to notes (COMM(NOTE)). This guarantees that the value and owner of note are not public. However, now that we don't know PK of the note's owner, how do we verify the transaction?\\
\\
Spending a note in zCash involves computing a zero-knowledge proof $\pi$. It requires the NOTE's spender to prove the following:

\begin{itemize}
    \item The commitment COMM(NOTE) exists in a Merkle tree with all notes
    \item That they have the private key SK, corresponding to the note's public key PK
    \item The NULL(N) is equal to the nullifier provided (T)
\end{itemize}

If the proof verification passes, the node can check if the note has been spent previously by searching for T in a Merkle tree with published nullifiers. This results in the transaction being accepted and added to the blockchain. Along with this T is added to the set of spent nullifiers.

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Zero-Knowledge Proofs}

In 1985. Goldwasser, Micali and Rackoff published a paper with an interesting twist. Most papers discussed methods of combating a dishonest prover, trying to deceive an honest verifier. Their work took a completely different approach: What information could a verifier obtain from a prover? They defined a new class of languages - IP (Interactive Proof). IP contains language L for which there is an interactive protocol between the prover P and a verifier V, after which P has convinced V with a non-negligible probability that the statement s is in the language L.\\
\\
The interactive proof must satisfy the following properties:
\begin{itemize}
    \item \textbf{Completeness} If the statement \textit{s} is in \textit{L}, there exists a prover \textit{P} that can convince the poly-time verifier \textit{V} of this, with probability of at least 2/3.
    $$ s \in L \implies \exists P Pr[out_V \langle V, P \rangle (s) = 1 ] \geq 2/3 $$
    \item \textbf{Soundness} If the statement \textit{s} isn't in \textit{L}, no prover \textit{P} can convince the poly-time verifier \textit{V} that it is with probability 1/3 or greater.
    $$ s \notin L \implies \forall P Pr[out_V \langle V, P \rangle (s) = 1 ] < 1/3 $$
\end{itemize}

The choice of constants 2/3 and 1/3 is arbitrary, because probability amplification can be used until we are satisfied with the probability of error.\\
\\
Another important property that a proof may have is \textbf{zero-knowledge}. While two previous properties are tied to different provers, zero-knowledge states that all verifiers can learn only that the statement \textit{s} belongs to the language \textit{L}. This statement can be formalized using a simulator and a transcript. \textit{V} can generate the transcript with the same distribution as the messages exchanged during the protocol, without ever communicating with \textit{P}. Hence, \textit{V} learns nothing from \textit{P}, other than $s \in L$.\\
\\
Unfortunately, zero-knowledge proofs described are interactive. They cannot be used in blockchain because every verification of the blocks would require all parties to be online and exchange messages with the verifier. Blum, Feldman and Micali introduced \textbf{N}on-\textbf{I}nteractive \textbf{Z}ero-\textbf{K}nowledge proofs (NIZK - pronounced \textit{nee-zeek}). These proofs require a preparation step - establishment of a common reference string (CRS). This is performed once and CRS is later used for proof generation and verification.

\section{zk-SNARKs}

\subsection{Introduction}
zk-SNARKs are a cryptographic primitive used for zero-knowledge proofs. Their name stands for \textbf{Z}ero-\textbf{K}nowledge \textbf{S}uccinct \textbf{N}on-Interactive \textbf{Ar}guments of \textbf{K}nowledge. They cannot be considered true proofs, but arguments because they hold only computationally. The main strength lies in succinctness and non-interactivity - zk-SNARK proofs are short and can be verified offline. Furthermore, they can be used to prove any statement that can be represented as a circuit (eg. any finite computation on a modern CPU). This can be useful in a number of contexts, not only for cryptocurrencies. (eg. verifieable cloud execution). zk-SNARKs aren't interactive so they require a preparation stage to generate a CRS. Most of the material in this section is based on a series of articles by Vitali Buterin, with motivation and reasoning between the steps made clearer. For further information consult original papers, as well as zCash blog and protocol. % cite Pinocchio, Groth, zCash blog posts, articles by Vitali Buterin

\subsection{Arithmetic Circuit}

The calculation we want to perform starts as a program. To generate a proof for it, we need to convert it into an arithmetic circuit consisting only of four basic operations: addition, subtraction, multiplication and division. Different variables in the programs and intermediate results are represented by different wires in the circuit. Conditional execution can be simulated by performing all branches in parallel, and selecting one of them. Finite loops are unrolled, and function calls are inlined.

\subsection{R1CS Form}
The next step of generating a proof is making sure that all constraints in the circuit are satisfied (eg. that multiplication gates actually perform multiplication). This is achieved by conversion of the circuit into R1CS form (Rank 1 Constraint System). Every gate is transformed independently. It consists of a vector S, containing values of all wires in the circuit (and value 1). Additionally, R1CS form comprises vectors $A_i$, $B_i$, and $C_i$, such that the following constraint is met:

$$ A_i \cdot S \times B_i \cdot S - C_i \cdot S = 0 $$

The conversion follows a standard procedure for all four basic operations, which is illustrated in FIGURE in the case of addition. Vectors A and B are used for selection and scaling of inputs to the gate, while the vector C scales and selects the output. We transform all gates as described.

\subsection{Quadratic Arithmetic Program}
Quadratic Arithmetic Program enables us to represent R1CS constraints for all gates at once. First, we enumerate all gates, and construct three polynomials (A(x), B(x), and C(x)) for every variable in the circuit. Polynomial for the j-th variable $A_j(x)$ is formed by interpolating it through the points with coordinates $(i, A_i[j])$. 
%, where GateIndex is the index assigned to gate when they were enumerated, $A_{GateIndex}$ is the corresponding A vector, and $A_{GateIndex} [i]$ is the value of the i-th constant in the vector
Polynomials can be interpolated using well-known algorithm such as Langrangian interpolation. Extracting previous values from the polynomial is possible by evaluating them at the corresponding variable index.\\
\\
Then, we form a new polynomial A(x) by arranging all $A_j$ vectors in a new vector, based on the index j, and taking a scalar product with S. We form polynomials B(x) and C(x) the same way.

$$ A(x) = \sum_{j = 1}^{number\,of\,gates} S_j \cdot A_j(x) $$

Considering that polynomials A(x), B(x) and C(x) are sums of interpolated polynomials multiplied by the corresponding element in S, we can evaluate them at variable indices and conclude that the following expression holds.

$$\forall t:\: [t \in \{1,\,2,\,3, \dots ,\,number\,of\,gates\} \implies A(t) \cdot B(t) - C(t) = 0]$$
\\
This implies that the polynomial $A(x) \cdot B(x) - C(x)$ is divisible by the polynomial $T(x) = (x-1)(x-2)...(x-number\,of\,gates)$, or more formally:

$$ A(x) \cdot B(x) - C(x) = H(x) \cdot T(x) $$

\subsection{Pinocchio Protocol}

This section presumes basic (operational) knowledge of elliptic curves and pairings, which can be found in APPENDIX.\\
\\
The simplest way to verify that all checks that the circuit, or QAP, performs are satisfied, would be to reveal all values. However, that would leak sensitive information such as private key, available funds, transferred ZEC... Providing just a polynomial divisible by T(x) would be meaningless, because it could have been forged. The primitive we need should provide us with a way to check that the polynomial was constructed in a specific way, while letting us verify that it is indeed divisible by T(x). Pinocchio protocol uses  pairings (bilinear maps) to achieve that goal.\\
\\
Pairings can be used to check whether two pairs of elliptic curve points (A and B, C and D) have the same quotients:

$$ B / A \stackrel{?}{=} D / C $$
This is verified by computing two pairings:
$$ e(A, D) \stackrel{?}{=} e(B, C) $$
In case of $A = [k]B; C = [k]D$ we have:
$$ e([k]B, D) \stackrel{?}{=} e(B, [k]D)$$
We use property of the pairing to move the constant outside the pairings:
$$ [k]e(B, D) = [k]e(B, D) $$
If the pairs have the same quotients, both pairings will be equal.\\
\\
Using this idea, we can make sure that a polynomial hasn't been forged. We evaluate all polynomials at a secret coordinate t, so we obtain $A_j(t), B_j(t), C_j(t)$ for all gates in the circuit. By also adding these values multiplied by secret coefficients $k_a, k_b and k_c$, we are able to prevent the prover from using arbitrary polynomials. Considering that pairings operate on elliptic curve points, we will use these values to multiply the generator point G of a pairing-friendly curve. Accordingly, we add the following values to the trusted setup:

$$\forall j \in \{1, 2, 3, \ldots, number\;of\;gates\} : [A_j(t)]G, [A_j(t) \cdot k_A]G $$
$$\forall j \in \{1, 2, 3, \ldots, number\;of\;gates\} : [B_j(t)]G, [B_j(t) \cdot k_B]G $$ 
$$\forall j \in \{1, 2, 3, \ldots, number\;of\;gates\} : [C_j(t)]G, [C_j(t) \cdot k_C]G $$ 

The prover then needs to provide the following points to prove that they computed polynomials $A(x), B(x), C(x)$ correctly:

$$P_A = [A(t)]G, P_A' = [A(t) \cdot k_A]G$$
$$P_B = [B(t)]G, P_B' = [B(t) \cdot k_B]G$$
$$P_C = [C(t)]G, P_C' = [C(t) \cdot k_C]G$$

Considering that polynomials $A(x), B(x), C(x)$ are linear combinations of polynomials $A_j(x), B_j(x), C_j(x)$, respectively, they can be computed required points can be computed from the points in the trusted setup and the witness \textit{s} (coefficients of the linear combinations).\\
\\
The prover must also convince the verifier that they used the same coefficients for all polynomials. This is achieved by extending the trusted setup with the following points:

$$\forall j \in \{1, 2, 3, \ldots, number\;of\;gates\} : [(A_j(t) + B_j(t) + C_j(t)) \cdot k_abc]G $$

The prover then provides the point:

$$ P_{ABC}' = [(A(t) + B(t) + C(t)) \cdot k_abc]G $$

We can then use pairings to verify that $P_A + P_B + P_C$ and $P_{ABC}'$ actually differ $k_ABC$ times.

Finally, they need to prove that the polynomial $A(x) \cdot B(x) - C(x)$ is really divisible by $T(x)$. This is achieved by using the polynomial $H(x)$ to show that multiplying it by $T(x)$ gives us $A(x) \cdot B(x) - C(x)$$.