% Chapter Template

\chapter{Further Work} % Main chapter title

\label{Chapter8} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

Considering that OpenCL compilers generate large, memory-intensive GPU code, it may be possible to program Pippinger's algorithm in GPU assembly. \cite{bernstein2010ecc2k} have shown that we would need to use device-specific assembly to take advantage of all registers and control spills. This excludes intermediate assembly such as NVIDIA's PTX and would increase the load on developers. Programming an algorithm of this size in assembly often leads to cryptic, unmaintainable, and insecure code, which would go against zCash's principle. Code written like this would work only on a single device (or a family of devices), severely limiting its usefulness.\\
\\
The more viable solution involves creating custom hardware that supports 381-bit operations. These compute units would also have enough cache to store arrays for Pippinger's algorithm, as well as intermediate values. The biggest problem here is the design of the multiplier, although there are several available and tested proposals \cite{brinci2015efficient, quan2005high}. VHDL and Verilog can be used to implement the design on an FPGA. Using FPGAs would lead to lower frequency compared to GPU, but better allocation of silicon (eg. no need for floating-point hardware). Hardware wallet implemented like this could have higher performance and lower power consumption than commercial CPUs.